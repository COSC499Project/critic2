! Copyright (c) 2013 Alberto Otero de la Roza <alberto@carbono.quimica.uinovi.es>,
! Ángel Martín Pendás <angel@fluor.quimica.uniovi.es> and Víctor Luaña
! <victor@carbono.quimica.uniovi.es>. 
!
! critic2 is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or (at
! your option) any later version.
! 
! critic2 is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
! 
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.
!
!                           _ _   _      ____  
!                  ___ _ __(_) |_(_) ___|___ \
!                 / __| '__| | __| |/ __| __) |
!                | (__| |  | | |_| | (__ / __/ 
!                 \___|_|  |_|\__|_|\___|_____|
!                                     
program  critic
  use yt
  use bader
  use ewald
  use hirshfeld
  use qtree
  use bisect
  use flux
  use autocp
  use nci
  use rhoplot
  use fields
  use grd_atomic
  use varbas
  use struct
  use wien_private
  use pi_private
  use elk_private
  use molly_private
  use global
  use config
  use tools
  use tools_io
  use param
  implicit none

  ! command-line arguments
  integer :: argc
  character*(mline), allocatable :: argv(:)
  character*(mline) :: optv
  ! timer
  integer :: ipid
  ! parsing
  integer :: lp
  character*(mline) :: line, subline, word
  ! structure
  logical :: gooddata
  !
  integer :: level, plevel
  integer :: i, id, nn
  logical :: ll1, ok
  real*8 :: xx(3), rdum

  ! initialize parameters
  call param_init()

  ! input/output, arguments (tools_io)
  call ioinit()
  argc = command_argument_count()
  allocate(argv(argc))
  do i = 1, argc
     call getarg(i,argv(i))    
     argv(i) = trim(adjustl(argv(i))) // null
  end do
  call stdargs(argc,argv,optv)

  ! set default values and initialize the rest of the modules
  call global_init(argc,argv)
  call struct_init()
  call fields_init()
  deallocate(argv)

  ! header, interface, date
  call initial_banner()
  call config_write()
  call tictac('CRITIC2')
  call timer (0,ipid,'main',uout)
  call timer (1,ipid,'main',uout)

  ! Start reading
  do while (fgetline(uin,line))
     lp=1
     word = lgetword(word,line,lp)
     subline = line(lp:)

     ! comment = #
     if (word(1:1) .eq. '#' .or. equal(word,null)) then

     ! crystal
     elseif (equal (word,'crystal'//null) .or. equal(word,'molecule'//null)) then
        ! read the crystal enviornment
        call struct_crystal_input(subline,equal(word,'molecule'//null))   
        ! initialize the radial densities
        call grda_init(.true.,.true.,.true.)
        ! set the promolecular density as reference
        call set_reference(0)
        ! we are good to go
        gooddata = .true.

     ! clearsym/clearsymm
     elseif (equal(word,'clearsym'//null) .or. equal(word,'clearsymm'//null)) then
        call struct_clearsym() 

     ! q/qat, zpsp, nocore
     elseif (equal(word,'q'//null) .or. equal(word,'qat'//null) &
        .or. equal(word,'zpsp'//null) .or. equal(word,'nocore'//null)) then
        if (.not. gooddata) call ferror('critic2','need crystal before q/qat/zpsp/nocore',faterr)
        call struct_charges(line)
        ll1 = equal(word,'zpsp'//null) .or. equal(word,'nocore'//null)
        call grda_init(ll1,.not.ll1,.true.)
           
     ! write
     elseif (equal (word,'write'//null)) then
        if (.not. gooddata) call ferror('critic2','need crystal before write',faterr)
        call struct_write(subline)

     ! load
     elseif (equal (word,'load'//null)) then
        if (.not. gooddata) call ferror('critic2','need crystal before load',faterr)
        call fields_load(subline,id)
        if (refden == 0) call set_reference(id)

     ! unload
     elseif (equal (word,'unload'//null)) then
        if (.not. gooddata) call ferror('critic2','need crystal before unload',faterr)
        ok = isinteger(id,line,lp)
        if (.not.ok .or..not.fused(id)) call ferror('critic2','wrong field id in UNLOAD',faterr)
        call fields_unload(id)
        if (refden == id) call set_reference(0)

     ! setfield
     elseif (equal (word,'setfield'//null)) then
        if (.not. gooddata) call ferror('critic2','need crystal before setfield',faterr)
        ok = isinteger(id,line,lp)
        if (.not.ok) id = refden
        call setfield(id,line(lp:))

     ! reference
     elseif (equal (word,'reference'//null)) then
        if (.not. gooddata) call ferror('critic2','need crystal before reference',faterr)
        ok = isinteger(id,line,lp)
        if (.not.ok) call ferror('critic2','wrong REFERENCE syntax',faterr)
        if (.not.fused(id)) call ferror('critic2','REFERENCE: field is not allocated',faterr)
        call set_reference(id)

     ! point
     elseif (equal(word,'point'//null)) then
        if (.not. gooddata) call ferror('critic2','need crystal before point',faterr)
        call rhoplot_point(subline)

     ! line
     elseif (equal(word,'line'//null)) then
        if (.not. gooddata) call ferror('critic2','need crystal before line',faterr)
        call rhoplot_line(subline)

     ! plane
     elseif (equal(word,'plane'//null)) then
        if (.not. gooddata) call ferror('critic2','need crystal before plane',faterr)
        call rhoplot_plane(subline)

     ! cube
     elseif (equal(word,'cube'//null)) then
        if (.not. gooddata) call ferror('critic2','need crystal before cube',faterr)
        call rhoplot_cube(subline)

     ! grdvec
     elseif (equal (word,'grdvec'//null)) then
        if (.not. gooddata) then
           call ferror('critic','crystal environment not set.',faterr)
        end if
        call rhoplot_grdvec()

     ! nciplot
     elseif (equal(word,'nciplot'//null)) then
        if (.not. gooddata) call ferror('critic2','need crystal before nciplot',faterr)
        call nciplot()

     ! benchmark 
     elseif (equal (word,'benchmark'//null)) then
        if (.not. gooddata) call ferror('critic2','need crystal before benchmark',faterr)
        ok = isinteger(nn,line,lp)
        if (.not. ok) nn = 10000
        call benchmark(nn)

     ! auto
     elseif (equal (word,'auto'//null)) then
        if (.not. gooddata) call ferror('critic2','need crystal before auto',faterr)
        call autocritic(subline)

     ! autogrid
     elseif (equal (word,'autogrid'//null)) then
        if (.not. gooddata) call ferror('critic2','need crystal before autogrid',faterr)
        call autogrid(subline)

     ! autogrid
     elseif (equal (word,'cpreport'//null)) then
        if (.not. gooddata) call ferror('critic2','need crystal before cpreport',faterr)
        call cpreport(subline)

     ! newton
     elseif (equal(word,'newton'//null)) then
        if (.not. gooddata) call ferror('critic2','need crystal before newton',faterr)
        ok = isreal(xx(1),line,lp)
        ok = ok .and. isreal (xx(2),line,lp)
        ok = ok .and. isreal (xx(3),line,lp)
        if (.not. ok) &
           call ferror('critic','bad syntax in newton',faterr)
        ok = isreal(rdum,line,lp)
        if (.not.ok) rdum = 1d-12
        call optim(xx,rdum) 

     ! check
     elseif (equal (word,'check'//null)) then
        if (.not. gooddata) call ferror('critic2','need crystal before check',faterr)
        call check(subline)

     ! fluxprint
     elseif (equal(word,'fluxprint'//null)) then
        if (.not. gooddata) call ferror('critic2','need crystal before fluxprint',faterr)
        call fluxprint()

     ! integrable
     elseif (equal(word,'integrable'//null)) then
        if (.not. gooddata) call ferror('critic2','need crystal before integrable',faterr)
        call fields_integrable(subline)

     ! basinplot
     elseif (equal (word,'basinplot'//null)) then
        if (.not. gooddata) call ferror('critic2','need crystal before basinplot',faterr)
        call basinplot(subline)

     ! bundleplot
     elseif (equal (word,'bundleplot'//null)) then
        if (.not. gooddata) call ferror('critic2','need crystal before bundleplot',faterr)
        call bundleplot(subline)

     ! sphereintegrals
     elseif (equal (word,'sphereintegrals'//null)) then
        if (.not. gooddata) call ferror('critic2','need crystal before sphereintegrals',faterr)
        call sphereintegrals(subline)

     ! integrals
     elseif (equal(word,'integrals'//null)) then
        if (.not. gooddata) call ferror('critic2','need crystal before integrals',faterr)
        call integrals(subline)

     ! qtree 
     elseif (equal(word,'qtree'//null)) then
        if (.not. gooddata) call ferror('critic2','need crystal before qtree',faterr)
        ok = isinteger(level,line,lp)
        if (.not.ok) level = 6
        ok = isinteger(plevel,line,lp)
        if (.not.ok) plevel = 0
        call qtree_integration(level,plevel)

     ! yt
     elseif (equal(word,'yt'//null)) then
        call yt_integrate(subline)

     ! bader
     elseif (equal(word,'bader'//null)) then
        call bader_integrate(subline)

     ! sphfactor
     elseif (equal(word,'sphfactor'//null)) then
        if (.not. gooddata) call ferror('critic2','need crystal before sphfactor',faterr)
        call qtree_setsphfactor(subline)

     ! root
     elseif (equal(word,'root'//null)) then
        if (.not. gooddata) call ferror('critic2','need crystal before sphfactor',faterr)
        fileroot = getword(fileroot,line,lp)
        fileroot = fileroot(1:leng(fileroot))

     ! hirshfeld
     elseif (equal (word,'hirshfeld'//null)) then
        if (.not. gooddata) call ferror('critic2','need crystal before hirshfeld',faterr)
        call hirsh_props_grid()

     ! ewald
     elseif (equal (word,'ewald'//null)) then
        if (.not. gooddata) call ferror('critic2','need crystal before ewald',faterr)
        call ewald_energy(rdum)
        write (uout,'("* Ewald electrostatic energy (Hartree) = ",1p,E20.12/)') rdum

     ! ws
     elseif (equal (word,'ws'//null)) then
        if (.not. gooddata) call ferror('critic2','need crystal before ws',faterr)
        call wigner((/0d0,0d0,0d0/),.true.)

     ! environ
     elseif (equal (word,'environ'//null)) then
        if (.not. gooddata) call ferror('critic2','need crystal before environ',faterr)
        ok = isinteger(nn,line,lp)
        if (.not.ok) nn = 10
        call atomshell(nneq,nn)

     ! sum
     elseif (equal (word,'sum'//null)) then
        if (.not. gooddata) call ferror('critic2','need crystal before sum',faterr)
        ok = isinteger(id,line,lp)
        if (.not.ok) id = refden
        if (f(id)%type /= type_grid) call ferror("sum","sum can only be used with grids",faterr)
        write (uout,'("SUM (",I2,") = ",1p,E22.14/)') id, sum(f(id)%f)

     ! min
     elseif (equal (word,'min'//null)) then
        if (.not. gooddata) call ferror('critic2','need crystal before min',faterr)
        ok = isinteger(id,line,lp)
        if (.not.ok) id = refden
        if (f(id)%type /= type_grid) call ferror("min","min can only be used with grids",faterr)
        write (uout,'("MIN (",I2,") = ",1p,E22.14/)') id, minval(f(id)%f)

     ! max
     elseif (equal (word,'max'//null)) then
        if (.not. gooddata) call ferror('critic2','need crystal before max',faterr)
        ok = isinteger(id,line,lp)
        if (.not.ok) id = refden
        if (f(id)%type /= type_grid) call ferror("max","max can only be used with grids",faterr)
        write (uout,'("MAX (",I2,") = ",1p,E22.14/)') id, maxval(f(id)%f)

     ! mean
     elseif (equal (word,'mean'//null)) then
        if (.not. gooddata) call ferror('critic2','need crystal before mean',faterr)
        ok = isinteger(id,line,lp)
        if (.not.ok) id = refden
        if (f(id)%type /= type_grid) call ferror("mean","mean can only be used with grids",faterr)
        write (uout,'("MEAN (",I2,") = ",1p,E22.14/)') id, sum(f(id)%f) / (f(id)%n(1)*f(id)%n(2)*f(id)%n(3))

     ! count
     elseif (equal (word,'count'//null)) then
        if (.not. gooddata) call ferror('critic2','need crystal before count',faterr)
        ok = isinteger(id,line,lp)
        if (ok) then
           ok = isreal(rdum,line,lp)
           if (.not.ok) rdum = 0d0
        else
           id = refden
           rdum = 0d0
        end if
        if (f(id)%type /= type_grid) call ferror("count","count can only be used with grids",faterr)
        write (uout,'("COUNT (",I2," > ",1p,E22.14,0p,") = ",I10/)') id, rdum, count(f(id)%f > rdum)

     ! testrmt
     elseif (equal (word,'testrmt'//null)) then
        if (.not. gooddata) call ferror('critic2','need crystal before testrmt',faterr)
        call testrmt(refden,3)

     ! run/system
     elseif (equal(word,'run'//null) .or. equal(word,'system'//null)) then
        call spawn (line(lp:len(line)))
        
     ! end
     elseif (equal (word,'end'//null)) then
        exit
        ! pass unknown to setvariables
     else
        lp = 1
        call setvariables (line, lp)
     endif
  enddo

  ! clean up
  call pi_end()
  call struct_end()
  call fields_end()

  write (uout,'("CRITIC2 ended succesfully (",I3," WARNINGS, ",I3," COMMENTS)"/)')&
     nwarns, ncomms
  call tictac('CRITIC2')
  call timer (4,ipid,'main',-1)
  call timer (6,ipid,'main',uout)

contains
  subroutine set_reference(id)
    implicit none

    integer, intent(in) :: id

    ! header and change refden
    refden = id
    write (uout,'("* The field number ",I2," is now REFERENCE."/)') refden

    ! initialize CP list and move hydrogens
    call init_cplist()
    call hydrogen_report()

    ! define second integrable property as the valence charge.
    nprops = max(2,nprops)
    integ_prop(2)%used = .true.
    integ_prop(2)%itype = itype_fval
    integ_prop(2)%fid = id
    integ_prop(2)%prop_name = "Charge"

    ! define third integrable property as the valence laplacian.
    nprops = max(3,nprops)
    integ_prop(3)%used = .true.
    integ_prop(3)%itype = itype_lapval
    integ_prop(3)%fid = id
    integ_prop(3)%prop_name = "Lap"

    ! report
    call fields_integrable_report()

    ! reset defaults for qtree
    if (f(refden)%type == type_grid) then
       gradient_mode = 1
       if (INT_radquad_errprop_default) INT_radquad_errprop = 2
    else
       gradient_mode = 2
       if (INT_radquad_errprop_default) INT_radquad_errprop = 3
    end if

  end subroutine set_reference
end program

